# LeetCode 191.位1的个数

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为[汉明重量](https://baike.baidu.com/item/汉明重量)）。



示例 1：

```
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

```

示例 2：

```
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```



示例 3：

```
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```



## 解题思路

这道题实际上是非常简单的，我们可以通过两种思路来解决，但是需要一点位运算的前置知识

### 对输入进行右移

为了得到位1的个数，我们可以直接对输入进行右移，如果移出的位上值为1，则对ans++

```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count = 0;
        while (n != 0) {
            // n&1得到的是当前n最后一位的值，为1则count加一
            count += n & 1;
            
            //注意下面一行代码
            n >>= 1;
        }
        return count;
    }
}
```

这道题逻辑上是这样做的，但是以上代码是有一些问题的。我们知道在计算机中，通过32位二进制表示的数首位是一个标志位，如果是负数，这个标志位就为1。上面代码中n>>=1是**算术右移**,也就是对非标志位的剩余31位进行右移，不会改变首位的值，n的结果永远不为0，这也是上面代码出现问题的原因。

为了解决这个问题，我们在这里介绍一种新的右移运算**>>>**,也就是逻辑右移，这个运算符号会连同标志位一起右移，只要把我们上述代码中的n>>=1改成n>>>1就可以了

在这里补充一点，由于逻辑右移的特性，笔者在二分查找的时候使用>>>来求mid的值，因为他会连同标志位一起右移，因此在二分法求mid的时候非常好用，可以解决整数溢出的问题。一般我们在求mid的时候都是mid=(left+right)/2，经验丰富的同学可能会知道这样做会有溢出的风险，因此会改成(right-left)/2+left。如果我们直接写mid = (left+right)>>>1，就直接规避了溢出的问题。



### 设法消掉n的二进制表示中的1

假设我们现在有一个八位的二进制数n，我们想去掉他二进制数中的最后一个一，有没有什么简单的方法呢？

我们可以通过二进制的位运算来高效解决这个问题，我们令n=n&(n-1),就可以了，我们来看图

![image-20210322111053528](C:\Users\慈凯瑜\AppData\Roaming\Typora\typora-user-images\image-20210322111053528.png)

我们通过令n-1，来使原来最后一个1变为0，其后面的0全部变为1，然后通过与运算来消掉最后一个1。

回到本题，我们可以通过这样的思路来迭代求得最终的结果，只要当前n不为零，就进行上述运算，最后得到结果

```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int bits = 0;
        while(n!=0){
            bits++;
            n &= n-1;
        }
        return bits;
    }
}
```



